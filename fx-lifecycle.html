<!--
  Provides proper batched lifecycle for DOM mutation in apps.
-->
<script>
(function() {
"use strict";

// These are also states.
const FORBIDDEN = 0;
const READ = 1;
const WRITE = 2;

// These are special types of handler that map to states.
const ACCESSOR = 3;
const VALUE = 4;
const INLINE_STYLE = 5;
const COMPUTED_STYLE = 6;
const CLASS_LIST = 7;
const DATASET = 8;

const PrototypeProperties = {
  "Document": [
    ["execCommand", WRITE],
    ["elementFromPoint", READ],
    ["elementsFromPoint", READ],
    ["scrollingElement", ACCESSOR],
    ["write", FORBIDDEN],
    ["writeln", FORBIDDEN],
    ["open", FORBIDDEN],
    ["close", FORBIDDEN],
  ],
  "Node": [
    ["appendChild", WRITE],
    ["removeChild", WRITE],
    ["insertBefore", WRITE],
    ["textContent", WRITE],
  ],
  "Element": [
    ["scrollIntoView", WRITE],
    ["scrollBy", WRITE],
    ["scrollTo", WRITE],
    ["getClientRects", READ],
    ["getBoundingClientRect", READ],
    ["computedRole", ACCESSOR],
    ["computedName", ACCESSOR],
    ["clientLeft", ACCESSOR],
    ["clientWidth", ACCESSOR],
    ["clientHeight", ACCESSOR],
    ["scrollLeft", ACCESSOR],
    ["scrollTop", ACCESSOR],
    ["scrollWidth", ACCESSOR],
    ["scrollHeight", ACCESSOR],
    ["scrollLeft", ACCESSOR],
    ["scrollTop", ACCESSOR],
    ["innerHTML", WRITE],
    ["outerHTML", WRITE],
    ["insertAdjacentHTML", WRITE],
    ["remove", WRITE],
    ["setAttribute", WRITE],
    ["removeAttribute", WRITE],
    ["attributes", FORBIDDEN],
    ["className", WRITE],
    ["classList", CLASS_LIST],
  ],
  "HTMLElement": [
    ["offsetLeft", ACCESSOR],
    ["offsetTop", ACCESSOR],
    ["offsetWidth", ACCESSOR],
    ["offsetHeight", ACCESSOR],
    ["offsetParent", ACCESSOR],
    ["innerText", ACCESSOR],
    ["outerText", ACCESSOR],
    ["focus", ACCESSOR],
    ["blur", ACCESSOR],
    ["style", INLINE_STYLE],
    ["dataset", DATASET],
  ],
  "CharacterData": [
    ["remove", WRITE],
    ["data", WRITE],
  ],
  "Range": [
    ["getClientRects", READ],
    ["getBoundingClientRect", READ],
  ],
  "MouseEvent": [
    ["layerX", ACCESSOR],
    ["layerY", ACCESSOR],
    ["offsetX", ACCESSOR],
    ["offsetY", ACCESSOR],
  ],
  "HTMLButtonElement": [
    ["reportValidity", READ],
  ],
  "HTMLDialogElement": [
    ["showModal", WRITE],
  ],
  "HTMLFieldSetElement": [
    ["reportValidity", READ]
  ],
  "HTMLImageElement": [
    ["width", ACCESSOR],
    ["height", ACCESSOR],
    ["x", ACCESSOR],
    ["y", ACCESSOR],
  ],
  "HTMLInputElement": [
    ["reportValidity", READ],
  ],
  "HTMLButtonElement": [
    ["reportValidity", READ]
  ],
  "HTMLKeygenElement": [
    ["reportValidity", READ]
  ],
  // TODO(esprehn): This doesn't really work, you can just do style.width to
  // force a layout, we need to overwrite getComputedStyle, but since you can
  // also save the return value we need to also probably make it reutrn a
  // wrapper.
  "CSSStyleDeclaration": [
    ["getPropertyValue", READ],
  ],
  "SVGSVGElement": [
    ["currentScale", ACCESSOR],
  ],
};

const InstanceProperties = {
  "window": [
    ["innerHeight", VALUE],
    ["innerWidth", VALUE],
    ["scrollX", VALUE],
    ["scrollY", VALUE],
    ["scrollBy", WRITE],
    ["scrollTo", WRITE],
    ["scroll", WRITE],
    ["alert", FORBIDDEN],
    ["prompt", FORBIDDEN],
    ["confirm", FORBIDDEN],
    ["find", FORBIDDEN],
    ["getMatchedCSSRules", FORBIDDEN],
    ["getComputedStyle", COMPUTED_STYLE],
  ],
};

var currentState = FORBIDDEN;

function handleForbidden(descriptor, propertyName) {
  function forbidden() {
    throw new Error(`${propertyName} is forbidden.`);
  }
  if ("value" in descriptor) {
    if (typeof descriptor.value == "function") {
      descriptor.value = forbidden;
    } else {
      descriptor.value = "forbidden";
    }
  } else {
    if (descriptor.get) {
      descriptor.get = forbidden;
    }
    if (descriptor.set) {
      descriptor.set = forbidden;
    }
  }
  return descriptor;
}

function handleRead(descriptor, propertyName) {
  var value = descriptor.value;
  if (typeof value == "function") {
    descriptor.value = function() {
      if (currentState != READ)
        throw new Error(`Can only call ${propertyName} inside FxDom.read.`);
      return value.apply(this, arguments);
    };
  } else if (descriptor.get) {
    var get = descriptor.get;
    descriptor.get = function() {
      if (currentState != READ)
        throw new Error(`Can only get ${propertyName} inside FxDom.read.`);
      return get.apply(this, arguments);
    };
  }
  return descriptor;
}

function handleWrite(descriptor, propertyName) {
  var value = descriptor.value;
  if (typeof value == "function") {
    descriptor.value = function() {
      if (currentState != WRITE)
        throw new Error(`Can only call ${propertyName} inside FxDom.write.`);
      return value.apply(this, arguments);
    };
  } else if (descriptor.set) {
    var set = descriptor.set;
    descriptor.set = function() {
      if (currentState != WRITE)
        throw new Error(`Can only set ${propertyName} inside FxDom.write.`);
      return set.apply(this, arguments);
    };
  }
  return descriptor;
}

function handleAccessor(descriptor, propertyName) {
    descriptor = handleRead(descriptor, propertyName);
    return handleWrite(descriptor, propertyName);
}

function handleValue(descriptor, propertyName) {
  // Some properties are actually on the instance of objects and we need
  // to replace them with accessors which magically delete themselves on
  // access, call into the v8 interceptor, and then add themselves back.
  // This won't be fast, but these are rarely accessed so it should be fine.
  descriptor.get = function() {
    if (currentState != READ)
      throw new Error(`Can only get ${propertyName} inside FxDom.read.`);
    delete this[propertyName];
    var result = this[propertyName];
    Object.defineProperty(this, propertyName, descriptor);
    return result;
  };
  return descriptor;
}

var getStyle = (function() {
  var getter = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "style").get;
  return function getStyle(element) {
    return getter.call(element);
  };
})();

// This doesn't expose the concept of !important in inline style, but honestly
// you shouldn't do that anyway.
class FxInlineStyle {
  constructor(element) {
    this.element = element;
  }
  set cssText(value) {
    if (currentState != WRITE)
      throw new Error(`Can only set cssText inside FxDom.write.`);
    getStyle(this.element).cssText = value;
  }
  get cssText() {
    return getStyle(this.element).cssText;
  }
  get(propertyName) {
    return getStyle(this.element).getPropertyValue(propertyName);
  }
  has(propertyName) {
    return this.get(propertyName) !== "";
  }
  set(propertyName, value) {
    if (currentState != WRITE)
      throw new Error(`Can only set inline style inside FxDom.write.`);
    getStyle(this.element).setProperty(propertyName, value);
  }
  delete(propertyName) {
    if (currentState != WRITE)
      throw new Error(`Can only remove style properties inside FxDom.write.`);
    getStyle(this.element).removeProperty(propertyName);
  }
}

function handleInlineStyle(descriptor, propertyName) {
  descriptor.get = function() {
    return new FxInlineStyle(this);
  };
  return descriptor;
}

var getComputedStyle = window.getComputedStyle;

class FxComputedStyle {
  constructor(element) {
    this.element = element;
  }
  get cssText() {
    if (currentState != READ)
      throw new Error(`Can only get cssText inside FxDom.read.`);
    return getComputedStyle(this.element).cssText;
  }
  get(propertyName) {
    if (currentState != READ)
      throw new Error(`Can only get style properties inside FxDom.read.`);
    return getComputedStyle(this.element).getPropertyValue(propertyName);
  }
}

function handleComputedStyle(descriptor, propertyName) {
  descriptor.value = function(element) {
    return new FxComputedStyle(element);
  };
  return descriptor;
}

var getClassList = (function() {
  var getter = Object.getOwnPropertyDescriptor(Element.prototype, "classList").get;
  return function getClassList(element) {
    return getter.call(element);
  };
})();

class FxClassList {
  constructor(element) {
    this.element = element;
  }
  add(className) {
    if (currentState != WRITE)
      throw new Error(`Can only add class names inside FxDom.write.`);
    getClassList(this.element).add(className);
  }
  has(className) {
    return getClassList(this.element).contains(className);
  }
  delete(className) {
    if (currentState != WRITE)
      throw new Error(`Can only remove class names inside FxDom.write.`);
    getClassList(this.element).remove(className);
  }
  // Extensions to the Set like interface:
  toggle(className) {
    if (currentState != WRITE)
      throw new Error(`Can only toggle class names inside FxDom.write.`);
    return getClassList(this.element).toggle(className);
  }
  // Extensions to the Set like interface:
  getNames() {
    var classes = getClassList(this.element);
    var result = [];
    for (var i = 0; i < classes.length; ++i)
      result.push(classes[i]);
    return result;
  }
}

function handleClassList(descriptor, propertyName) {
  descriptor.get = function() {
    return new FxClassList(this);
  };
  return descriptor;
}

var getDataset = (function() {
  var getter = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "dataset").get;
  return function getDataset(element) {
    return getter.call(element);
  };
})();

class FxDataset {
  constructor(element) {
    this.element = element;
  }
  get(name) {
    return getDataset(this.element)[name];
  }
  set(name, value) {
    if (currentState != WRITE)
      throw new Error(`Can only set dataset values inside FxDom.write.`);
    getDataset(this.element)[name] = value;
  }
  has(name) {
    var dataset = getDataset(this.element);
    return name in dataset;
  }
  delete(name) {
    var dataset = getDataset(this.element);
    delete dataset[name];
  }
  // TODO(esprehn): Replace with .entries().
  getKeys() {
    return Object.keys(getDataset(this.element));
  }
}

function handleDataset(descriptor, propertyName) {
  descriptor.get = function() {
    return new FxDataset(this);
  };
  return descriptor;
}

// This follows the enum order.
const HandlerMap = [
  handleForbidden,
  handleRead,
  handleWrite,
  handleAccessor,
  handleValue,
  handleInlineStyle,
  handleComputedStyle,
  handleClassList,
  handleDataset,
];

// We forbid access to Element#attributes and force you to use
// setAttribute/getAttribute/removeAttribute/hasAttribute and then add a new
// method getAttributeNames().
var attributesGetter = Object.getOwnPropertyDescriptor(Element.prototype, "attributes").get;
Element.prototype.getAttributeNames = function() {
  var attributes = attributesGetter.call(this);
  var result = [];
  for (var i = 0; i < attributes.length; ++i)
    result.push(attributes[i].name);
  return result;
};

function processMap(map, lookupCallback) {
  for (var typeName in map) {
    var object = lookupCallback(typeName);
    if (!object) {
      // For debugging, but logs about experimental features so don't do it
      // in production.
      // console.log(`${typeName} not found.`);
      continue;
    }
    var properties = map[typeName];
    for (var i = 0; i < properties.length; ++i) {
      var propertyName = properties[i][0];
      var handlerType = properties[i][1];
      var descriptor;
      // Don't try to get value types, it causes a read which forces a layout.
      if (handlerType != VALUE) 
        descriptor = Object.getOwnPropertyDescriptor(object, propertyName);
      else if (object.hasOwnProperty(propertyName))
        descriptor = {};
      if (!descriptor) {
        // For debugging, but logs about experimental features so don't do it
        // in production.
        // console.log(`${typeName}.${propertyName} not found.`);
        continue;
      }
      var newDescriptor = HandlerMap[handlerType](descriptor, propertyName);
      if (newDescriptor) {
        // delete object[propertyName];
        Object.defineProperty(object, propertyName, newDescriptor);
      }
    }
  }
}

processMap(PrototypeProperties, function(name) {
  var object = window[name];
  if (object)
    return object.prototype;
  return null;
});

processMap(InstanceProperties, function(name) {
  return window[name];
});

var readQueue = [];
var writeQueue = [];
var didScheduleQueues = false;
var insideRaf = false;

function scheduleProcessQueues() {
  if (didScheduleQueues)
    return;
  if (insideRaf)
    Promise.resolve().then(processQueues);
  else
    requestAnimationFrame(processQueues);
  didScheduleQueues = true;
}

var originalRequestAnimationFrame = window.requestAnimationFrame;
function fxRequestAnimationFrame(callback) {
  originalRequestAnimationFrame(function() {
    insideRaf = true;
    try {
      callback.apply(null, arguments);
    } finally {
      insideRaf = false;
    }
  });
}
window.requestAnimationFrame = fxRequestAnimationFrame;

function callIgnoringError(callback) {
  try {
    callback();
  } catch (e) {
    // rethrow in a clean callstack.
    setTimeout(function() {
      throw e;
    });
  }
}

function processQueue(queue) {
  for (var i = 0; i < queue.length; ++i)
    callIgnoringError(queue[i]);
}

function processQueues() {
  if (currentState != FORBIDDEN)
    throw new Error(`Invalid lifecycle state ${currentState}`);
  while (readQueue.length || writeQueue.length) {
    if (readQueue.length) {
      var currentReadQueue = readQueue;
      readQueue = [];
      currentState = READ;
      processQueue(currentReadQueue);
    }
    if (writeQueue.length) {
      var currentWriteQueue = writeQueue;
      writeQueue = [];
      currentState = WRITE;
      processQueue(currentWriteQueue);
    }
  }
  currentState = FORBIDDEN;
  didScheduleQueues = false;
}

class FxDom {
  static get currentState() { return currentState; }

  static read(callback) {
    readQueue.push(callback);
    scheduleProcessQueues();
  }

  static write(callback) {
    writeQueue.push(callback);
    scheduleProcessQueues();
  }
}

window.FxDom = FxDom;

})();
</script>
